## !!steps Before we start

### !!tabs rules.lua

```lua !
-- Performance and good practices are not the focus here.
-- Make it work, then make it pretty.
-- Keep it simple and fun.
```

## !!steps Let's start!

<span className="underline">love.load</span> is invoked (once at the beginning of the game), then <span className="underline">love.update</span> and <span className="underline">love.draw</span> are invoked every frame in that order.

```bash !console
git checkout f324ecefdb6737aeb2415d63b3b3e10b97d12a0b
```

### !!tabs main.lua

```lua !
function love.load()
end

function love.update(dt)
end

function love.draw()
end
```

### !!tabs player.lua

```lua !
local player = {}

function player.load()
end

function player.update(dt)
end

function player.draw()
end

return player
```

### !!tabs main.lua (updated)

```lua !
local player = require("player")

function love.load()
  player.load()
end

function love.update(dt)
  player.update(dt)
end

function love.draw()
  player.draw()
end
```

## !!steps Draw something! 1/3

Running our game would not show anything yet. Let's draw something simple.

### !!tabs player.lua

```lua !
local player = {}

function player.load()
end

function player.update(dt)
end

function player.draw()
end

return player
```


## !!steps Draw something! 2/3

Add properties to define the player position and size.

### !!tabs player.lua

```lua !
local player = {}

local PLAYER_SPRITES = {
  IDLE = love.graphics.newImage('assets/player/idle.png'),
}

function player.load()
  player.sprite = PLAYER_SPRITES.IDLE
  player.x = 100
  player.y = 100
  player.width = 64
  player.height = 64
end
```

## !!steps Draw something! 3/3

Let's draw a sprite to represent our player and a rectangle to represent its hitbox.


```bash !console
git checkout 7a15081291986d44c75de25f431379a5c15677a3
```

### !!tabs player.lua

```lua !
function player.draw()
  love.graphics.rectangle("line", player.x, player.y, player.width, player.height)
  love.graphics.draw(
    player.sprite,
    player.x,
    player.y,
    0, -- rotation angle,  from 0 to tau
    player.width/player.sprite:getWidth(), -- scale x
    player.height/player.sprite:getHeight(), -- scale y
    0, -- offset x
    32 -- offset y (to center this specific sprite)
  )
end
```

## !!steps Moving the player 1/6

Let's read keyboard input to move the player around.

### !!tabs player.lua

```lua !
function player.update(dt)
end
```

## !!steps Moving the player 2/6

This sets the position of the player directly, which can feel a bit janky.

```bash !console
git checkout b3b5f29a6af5e8675a3743b115ff91981061ee3f
```

### !!tabs player.lua

```lua !
function player.update(dt)
  local left = love.keyboard.isDown("left")
  local right = love.keyboard.isDown("right")
  local up = love.keyboard.isDown("up")
  local down = love.keyboard.isDown("down")

  if left then
    player.x = player.x - 100 * dt
  end

  if right then
    player.x = player.x + 100 * dt
  end

  if up then
    player.y = player.y - 100 * dt
  end

  if down then
    player.y = player.y + 100 * dt
  end
end
```

## !!steps Moving the player 3/6

Instead, we want our player (who is an astronaut) to move freely in the space.

### !!tabs player.lua

```lua !
function player.load()
  player.sprite = PLAYER_SPRITES.IDLE
  player.x = 100
  player.y = 100
  player.width = 64
  player.height = 64
end
```

## !!steps Moving the player 4/6

So let's define a velocity and speed.

### !!tabs player.lua

```lua !
function player.load()
  player.sprite = PLAYER_SPRITES.IDLE
  player.x = 100
  player.y = 100
  player.width = 64
  player.height = 64
  player.speed = 3
  player.velocity = { x = 0, y = 0 }
end

function player.update(dt)
end
```

## !!steps Moving the player 5/6

Instead of changing the position directly, we change the velocity based on input.

### !!tabs player.lua

```lua !
function player.update(dt)
  local left = love.keyboard.isDown("left")
  local right = love.keyboard.isDown("right")
  local up = love.keyboard.isDown("up")
  local down = love.keyboard.isDown("down")

  if left then
    player.x = player.x - 100 * dt
  end

  if right then
    player.x = player.x + 100 * dt
  end

  if up then
    player.y = player.y - 100 * dt
  end

  if down then
    player.y = player.y + 100 * dt
  end
end
```

## !!steps Moving the player 6/6

And apply that velocity to the position every frame.

```bash !console
git checkout 29187cd98a8f65264e9f2b441f839591ea4c4e6c
```

### !!tabs player.lua

```lua !
function player.update(dt)
  local left = love.keyboard.isDown("left")
  local right = love.keyboard.isDown("right")
  local up = love.keyboard.isDown("up")
  local down = love.keyboard.isDown("down")

  if left then
    player.velocity.x = player.velocity.x - player.speed * dt
  end

  if right then
    player.velocity.x =  player.velocity.x + player.speed * dt
  end

  if up then
    player.velocity.y =  player.velocity.y -  2*player.speed * dt
  end

  if down then
    player.velocity.y =  player.velocity.y +  2*player.speed * dt
  end

  player.x = player.x + player.velocity.x
  player.y = player.y + player.velocity.y
end
```


## !!steps Basic collisions 1/2

There are a couple of issues with this approach: The user can keep moving forever even past the screen bounds.

### !!tabs player.lua

```lua !
function player.update(dt)
  -- previous code

  player.x = player.x + player.velocity.x
  player.y = player.y + player.velocity.y
end
```

## !!steps Basic collisions 2/2

Let's fix that by clamping the position to the screen size.

```bash !console
git checkout 6d9bbe9b4ed07dbebd157e2b97790a0960ca67b9
```

### !!tabs player.lua

```lua !
function player.update(dt)
  -- previous code

  player.x = player.x + player.velocity.x
  player.y = player.y + player.velocity.y

  if player.x < 0 then
    player.velocity.x = 0
    player.x = 0
  elseif player.x > _WIDTH - player.width then
    player.velocity.x = 0
    player.x = _WIDTH- player.width
  end

  if player.y < 0 then
    player.velocity.y = 0
    player.y = 0
  elseif player.y > _HEIGHT - player.height then
    player.velocity.y = 0
    player.y = _HEIGHT- player.height
  end
end
```

### !!tabs main.lua

```lua !
_HEIGHT = love.graphics.getHeight()
_WIDTH = love.graphics.getWidth()
```

## !!steps Game background 1/4

Let's add a background to our game.

### !!tabs main.lua

```lua !
function love.load()
  player.load()
end

function love.draw()
  player.draw()
end
```

## !!steps Game background 2/4


```bash !console
git checkout f0bb1421d596edc121733c18184a60e423cf59ae
```

### !!tabs main.lua

```lua !
local background = love.graphics.newImage('assets/background.png')
local parallax

local function draw_background(parallax)
  love.graphics.draw(parallax.sprite, parallax.x, 0, 0, _WIDTH/parallax.width, _HEIGHT/parallax.height)
end

function love.load()
  parallax = {
    sprite = background,
    width = background:getWidth(),
    height = background:getHeight(),
    x = 0,
  }
  player.load()
end

function love.draw()
  draw_background(parallax)
  player.draw()
end
```

## !!steps Game background 3/4

Let's move the background to give a scrolling effect.

```bash !console
git checkout eedb2b87eb8d4db62a954179ffccf3898691df36
```

### !!tabs main.lua

```lua !
local background = love.graphics.newImage('assets/background.png')
local parallax

local function draw_background(parallax)
  if (parallax.x < -_WIDTH) then
    parallax.x = _WIDTH-1
  end
  love.graphics.draw(parallax.sprite, parallax.x, 0, 0, _WIDTH/parallax.width, _HEIGHT/parallax.height)
end

function love.update(dt)
  parallax.x = parallax.x-1
  player.update(dt)
end
```

## !!steps Game background 4/4

Let's make it infinite by drawing two backgrounds that loop.

```bash !console
git checkout d6b0bd21723ef99c20e0fd0ba53c3d2d2ea2210f
```

### !!tabs main.lua

```lua !
local parallax_a
local parallax_b

function love.load()
  parallax_a = {
    sprite = background,
    width = background:getWidth(),
    height = background:getHeight(),
    x = 0,
  }
  parallax_b = {
    sprite = background,
    width = background:getWidth(),
    height = background:getHeight(),
    x = _WIDTH,
  }
  player.load()
end

function love.update(dt)
  parallax_a.x = parallax_a.x-1
  parallax_b.x = parallax_b.x-1
  player.update(dt)
end

function love.draw()
  draw_background(parallax_a)
  draw_background(parallax_b)
  player.draw()
end
```

## !!steps Obstacles 1/6

Let's add some obstacles to avoid.

### !!tabs main.lua
```lua !
local obstacles = require("obstacles")

function love.load()
  -- previous code
  player.load()
  obstacles.load()
end

function love.update(dt)
  -- previous code
  player.update(dt)
  obstacles.update(dt)
end

function love.draw()
  -- previous code
  player.draw()
  obstacles.draw()
end
```

### !!tabs obstacles.lua

```lua !
local obstacles = {}

function obstacles.load()
end

function obstacles.update(dt)
end

function obstacles.draw()
end

return obstacles
```

## !!steps Obstacles 2/6

Spawn some obstacles outside of the screen and move them to the left.

### !!tabs obstacles.lua

```lua !
function obstacles.load()
  obstacles.list = {}
  obstacles.spawn_interval = 5
  obstacles.spawn_timer = 0
end

function obstacles.update(dt)
end

function obstacles.draw()
end
```

## !!steps Obstacles 3/6

Let's spawn obstacles at regular intervals.

### !!tabs obstacles.lua

```lua !
function obstacles.update(dt)
  obstacles.spawn_timer = obstacles.spawn_timer + dt
end

function obstacles.draw()
end
```

## !!steps Obstacles 4/6

Spawn the obstacles at random y positions.

### !!tabs obstacles.lua

```lua !
function obstacles.update(dt)
  obstacles.spawn_timer = obstacles.spawn_timer + dt
  if obstacles.spawn_timer > obstacles.spawn_interval then
    obstacles.spawn_timer = 0
    local obstacle_height = math.random(32, _HEIGHT/4)
    local obstacle_y = math.random(0, _HEIGHT - obstacle_height)
    table.insert(obstacles.list, {
      x = _WIDTH,
      y = obstacle_y,
      width = obstacle_height,
      height = obstacle_height
    })
  end
end

function obstacles.draw()
end
```

## !!steps Obstacles 5/6

Move the obstacles to the left and remove them when they go off screen.

### !!tabs obstacles.lua

```lua !
function obstacles.update(dt)
  -- previous code

  for i, wall in ipairs(obstacles.list) do
    wall.x = wall.x - 1.5 * dt * 60
    if wall.x + wall.width < 0 then
      table.remove(obstacles.list, i)
    end
  end
end

function obstacles.draw()
end
```

## !!steps Obstacles 6/6

Draw the obstacles.

```bash !console
git checkout a4bc9c670d294c7acf1207c099d50d5fc1d0ad87
```

### !!tabs obstacles.lua

```lua !
function obstacles.draw()
  for i = 1, #obstacles.list do
    local obstacle = obstacles.list[i]
    love.graphics.draw(
      block,
      obstacle.x, obstacle.y,
      0,
      obstacle.width/block:getWidth(),
      obstacle.height/block:getHeight()
    )
  end
end
```

## !!steps Player's Health 1/4

Before we can handle collisions, let's add a health system to the player.

### !!tabs player.lua

```lua !
local PLAYER_SPRITES = {
  IDLE = love.graphics.newImage('assets/player/idle.png'),
}

function player.load()
  -- previous code
  player.speed = 3
  player.velocity = { x = 0, y = 0 }
end

function player.draw()
  -- previous code
end
```

## !!steps Player's Health 2/4

### !!tabs player.lua

```lua !
local PLAYER_SPRITES = {
  IDLE = love.graphics.newImage('assets/player/idle.png'),
  LIVE = love.graphics.newImage('assets/player/live.png'),
}

function player.load()
  -- previous code
  player.speed = 3
  player.velocity = { x = 0, y = 0 }
  player.max_lives = 3
  player.lives = player.max_lives
end

function player.draw()
  -- previous code
end
```

## !!steps Player's Health 3/4

Draw the player's lives in the top-left corner.

### !!tabs player.lua

```lua !
function player.draw()
  -- previous code

  for i =1, player.lives do
    love.graphics.draw(
      PLAYER_SPRITES.LIVE,
      8 + (i-1) * 40, -- 8 px padding + 40px per heart
      16, -- 16 px from top
      0,
      40/PLAYER_SPRITES.LIVE:getWidth(),
      40/PLAYER_SPRITES.LIVE:getHeight()
    )
  end
end
```

## !!steps Player's Health 4/4

Let's add a damage function to the player.

```bash !console
git checkout 42ce6b6720ff640f3ff59f6e6ba8d7699bdc9109
```

### !!tabs player.lua

```lua !
function player.damage(amount, callback)
  player.lives = player.lives - amount
  if player.lives < 0 then
    player.lives = 0
    if callback then
      callback()
    end
  end
end
```

## !!steps Collisions 1/2

When an obstacle collides with the player, we want to reduce the player's health.

### !!tabs obstacles.lua
```lua !
local player = require("player")
function obstacles.update(dt)
  -- previous code
end
```

## !!steps Collisions 2/2
We can use AABB collision detection to check if two rectangles overlap.

### !!tabs obstacles.lua

```lua !
local player = require("player")
local utils = require("utils")

function obstacles.update(dt)
  -- previous code
  for i, wall in ipairs(obstacles.list) do
    -- previous code

    local is_colliding_player =
      utils.AABB_collision(player.x, player.y, player.width, player.height, wall.x, wall.y, wall.width, wall.height)

    if is_colliding_player then
      player.damage(1, function()
        print("Game Over!")
      end)
      table.remove(obstacles.list, i)
    end
  end
end
```

### !!tabs utils.lua

```lua !
local utils = {}

function utils.AABB_collision(ax, ay, aw, ah, bx, by, bw, bh)
    return (
      ax < bx + bw and
      ax + aw > bx and
      ay < by + bh and
      ay + ah > by
    )
end

return utils
```

## !!steps Polishing 1/

The player can move infinitely after the user stops pressing a key. Let's decrease the velocity over time to simulate friction.

### !!tabs player.lua
```lua !
function player.load()
  -- previous code
  player.max_lives = 3
  player.lives = player.max_lives
end

function player.update(dt)
  local left = love.keyboard.isDown("left")
  local right = love.keyboard.isDown("right")
  local up = love.keyboard.isDown("up")
  local down = love.keyboard.isDown("down")

  -- rest of code
end
```

## !!steps Polishing 2/

The player can move infinitely after the user stops pressing a key. Let's decrease the velocity over time to simulate friction.

```bash !console
git checkout 8907f5af4523c519c54e9d86a75813519a4a61bb
```

### !!tabs player.lua
```lua !
function player.load()
  -- previous code
  player.drag = 0.8 -- drag coefficient
  player.drag_start_at = 0.2 -- start applying drag after this threshold
  player.last_input = 0 -- time since last input
end

function player.update(dt)
  -- previous code
  local no_input = true

  if up or down or left or right then
    no_input = false
  end

  if no_input then
    player.last_input = player.last_input + dt
  else
    player.last_input = 0
  end

  if player.last_input > player.drag_start_at then
    player.velocity.y = utils.easeOutCirc(player.velocity.y, player.drag)
    player.velocity.x = utils.easeOutCirc(player.velocity.x, player.drag)
  end
end
```

### !!tabs utils.lua
```lua !
function utils.easeOutCirc(value, factor)
  local eased = math.sqrt(1 - math.pow(factor - 1, 2))
  return value * eased
end
```