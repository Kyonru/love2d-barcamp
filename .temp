local PLAYER_SPRITES = {
  IDLE = love.graphics.newImage('assets/player/idle.png'),
  DOWN = love.graphics.newImage('assets/player/down.png'),
  UP = love.graphics.newImage('assets/player/up.png'),
  HIT = love.graphics.newImage('assets/player/hit.png'),
  MOVE = love.graphics.newImage('assets/player/move.png'),
  LIVE = love.graphics.newImage('assets/player/front.png'),
  BACK = love.graphics.newImage('assets/player/hit.png')
}

local player = {
  x = 0,
  y = 0,
  width = 64,
  height = 64,
  speed = 3,
  velocity = {
    x = 0,
    y = 0
  },
  lives = 3,
  max_lives = 3,
  dash = 2,
  wait_for_dash = 0,
  wait_for_dash_duration = 0.5,
  y_direction = 0,
  x_direction = 0,
  sprite = PLAYER_SPRITES.IDLE,
  last_input = 0,
  drag = 1.005,
  drag_start_at = 0.1,
  wind_force = 0.5
}

local _WIDTH = love.graphics.getWidth()
local _HEIGHT = love.graphics.getHeight()
local background = love.graphics.newImage('assets/background.png')

local block = love.graphics.newImage('assets/block.png')

local walls = {}
local wall_spawn_timer = 0
local spawn_wall_every = 5

local parallax_a = {
  x = 0,
  sprite = background
}

local parallax_b = {
  x = _WIDTH,
  sprite = background
}

local scroll = 0

local function draw_background(parallax)
  if (parallax.x < -_WIDTH) then
    parallax.x = _WIDTH-1
  end
  love.graphics.draw(parallax.sprite, parallax.x, 0, 0, _WIDTH/background:getWidth(), _HEIGHT/background:getHeight())
end

local function draw_ui()
  for i =1, player.lives do
    love.graphics.draw(PLAYER_SPRITES.LIVE, 8 + (i-1) * 40, 16, 0, 40/PLAYER_SPRITES.LIVE:getWidth(), 40/PLAYER_SPRITES.LIVE:getHeight())
  end
end

local function draw_walls()
  for i, wall in ipairs(walls) do
    love.graphics.rectangle("line", wall.x, wall.y, wall.width, wall.height)
    love.graphics.draw(block, wall.x, wall.y, 0, wall.width/block:getWidth(), wall.height/block:getHeight())
  end
end

function love.load()
  player.y = (_HEIGHT-player.height)/2
end

function love.update(dt)
  local left = love.keyboard.isDown("a")
  local right = love.keyboard.isDown("d")
  local up = love.keyboard.isDown("w")
  local down = love.keyboard.isDown("s")
  local dash = love.keyboard.isDown("space")

  parallax_a.x = parallax_a.x-1
  parallax_b.x = parallax_b.x-1

  player.y_direction = 0
  player.x_direction = 0

  local no_input = true

  if left then
    player.velocity.x = player.velocity.x - player.speed * dt
    player.sprite = PLAYER_SPRITES.BACK
    player.x_direction = -1
    no_input = false
  end

  if right then
    player.velocity.x =  player.velocity.x + player.speed * dt
    player.sprite = PLAYER_SPRITES.MOVE
    player.x_direction = 1
    no_input = false
  end

  if up then
    player.velocity.y =  player.velocity.y -  2*player.speed * dt
    player.sprite = PLAYER_SPRITES.UP
    player.y_direction = -1
    no_input = false
  end

  if down then
    player.velocity.y =  player.velocity.y +  2*player.speed * dt
    player.sprite = PLAYER_SPRITES.DOWN
    player.y_direction = 1
    no_input = false
  end

  if dash and (player.y_direction ~=0 or player.x_direction ~= 0) and player.wait_for_dash <= 0  then
    local y_positive = player.y_direction > 0
    local x_positive = player.x_direction > 0

    local should_cancel_current_y_velocity = (player.velocity.y > 0 and not y_positive) or (player.velocity.y < 0 and y_positive)
    if should_cancel_current_y_velocity then
      player.velocity.y = 0
    end

    local should_cancel_current_x_velocity = (player.velocity.x > 0 and not x_positive) or (player.velocity.x < 0 and x_positive)
    if should_cancel_current_x_velocity then
      player.velocity.x = 0
    end

    player.velocity.y = player.velocity.y + player.dash*player.y_direction
    player.velocity.x =  player.velocity.x + player.dash*player.x_direction
    player.wait_for_dash = player.wait_for_dash_duration
    no_input = false
  end

  player.x = player.x + player.velocity.x
  player.y = player.y + player.velocity.y

  if player.x < 0 then
    player.velocity.x = 0
    player.x = 0
  elseif player.x > _WIDTH - player.width then
    player.velocity.x = 0
    player.x = _WIDTH- player.width
  end

  if player.y < 0 then
    player.velocity.y = 0
    player.y = 0
  elseif player.y > _HEIGHT - player.height then
    player.velocity.y = 0
    player.y = _HEIGHT- player.height
  end

  if player.wait_for_dash > 0 then
    player.wait_for_dash = player.wait_for_dash-dt
  elseif player.wait_for_dash < 0 then
    player.wait_for_dash = 0
  end

  if no_input then
    player.last_input = player.last_input + dt
    player.velocity.x = player.velocity.x - player.wind_force*dt
  else
    player.last_input = 0
  end

  if player.last_input > player.drag_start_at then
    -- TODO: Change to smoothing function, easing_out or something
    player.velocity.y = player.velocity.y / player.drag
    player.velocity.x = player.velocity.x / player.drag
  end

  wall_spawn_timer = wall_spawn_timer + dt
  if wall_spawn_timer > spawn_wall_every then
    wall_spawn_timer = 0
    local wall_height = math.random(32, _HEIGHT/4)
    local wall_y = math.random(0, _HEIGHT - wall_height)

    local wall_width = math.random(32, 128)
    table.insert(walls, {
      x = _WIDTH,
      y = wall_y,
      width = wall_height,
      height = wall_height
    })
  end

  for i, wall in ipairs(walls) do
    wall.x = wall.x - 1.5 * dt * 60
    if wall.x + wall.width < 0 then
      table.remove(walls, i)
    end
  end
end

function love.draw()
  draw_background(parallax_a)
  draw_background(parallax_b)

  love.graphics.rectangle("line", player.x, player.y, player.width, player.height)
  love.graphics.draw(
    player.sprite,
    player.x,
    player.y,
    0,
    (player.width/player.sprite:getWidth()),
    player.height/player.sprite:getHeight(),
    0,
    32
  )
  draw_walls()
  draw_ui()
end

